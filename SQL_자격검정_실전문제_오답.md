# SQL 자격검정 실전문제 오답
- SQLD를 위해 공부해봅시다.


## 1과목 1장 데이터 모델의 이해

### 1
#### 데이터 모델링의 특징

1. **추상화** : 일정한 형식에 맞추어 표현한다.
2. **단순화** : 제한된 표기법이나 언어로 표현한다.
3. **명확성** : 이해가 쉽게 표현한다.

모델링은 단지 시스템 구현만을 위해 수행하는 태스크가 아니며, 시스템 구현을 포함한 업무 분석 및 업무 형상화를 하는 목적도 있다.

#### 정답: 2


### 2
데이터 모델링은 단지 데이터베이스만을 구축하기 위한 용도로 쓰이는 것이 아니라 데이터 모델링 자체로도 업무를 설명하고 분석하는 부분에서 매우 중요한 의미가 있다.

#### 정답: 3


### 3
#### 데이터 모델링을 할 때 유의할 사항
1. **중복**
    - 데이터 모델은 같은 데이터를 사용하는 사람, 시간, 그리고 장소를 파악하는 데 도움을 주어 데이터베이스가 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록 한다.
    - 데이터 중복 저장 방지
2. **비유연성**
    - 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄인다.
    - 데이터 정의와 데이터 사용 프로세스 분리
3. **비일관성**
    - 데이터 모델링을 할 때 데이터와 데이터 간의 상호 연관 관계에 대해 명확하게 정의하여 위험을 사전에 예방한다.

테이블 간의 연계성을 높이면 데이터 모델이 업무 변경에 대해 취약하게 만드는 단점에 해당한다. 비일관성을 유발할 수 있다.

#### 정답: 3


### 4
3번 풀이 참고

#### 정답: 2


### 5
#### DB의 3층 스키마
1. **외부 스키마**
    - 각 사용자 단계의 개인적 DB 스키마, 사용자 관점, 응용 프로그램이 접근하는 DB를 정의
2. **개념 스키마**
    - 조직 전체의 통합된 DB 스키마, 설계자 관점, 데이터 모델링의 지향점
    - 통합된 모든 사용자의 관점
3. **내부 스키마**
    - 물리적으로 데이터가 저장되는 방법을 표현하는 스키마, 개발자 관점, 물리적 저장 구조

#### DB의 3단계 구조
- 외부 단계, 개념적 단계, 내부적 단계
- 외부 단계와 개념적 단계 사이에서는 논리적 데이터 독립성 고려
- 개념적 단계와 내부적 단계 사이에서는 물리적 데이터 독립성 고려

View 단계는 여러 사용자 관점으로 구성하는 외부스키마에 해당한다.

#### 정답: 3


### 8
이건 그냥 보기에서 알아둬야 할 것들만 적어놔야겠다.

1. ERD에서 엔터티를 어디에 배치하는가에 대한 문제는 필수사항은 아니지만 가독성 측면에서 생각하여 적절하게 배치할 필요성이 있다. 일반적으로 사람의 눈은 **왼쪽에서 오른쪽, 위쪽에서 아래쪽**으로 이동하는 경향이 있기 때문에 데이터 모델링에서도 가장 중요한 엔터티를 **왼쪽 상단**에 배치하고 이것을 중심으로 다른 엔터티를 나열하면서 전개하면 사람의 눈이 따라가기에 편리한 데이터 모델을 작성할 수 있다.
2. 일반적으로 ERD를 작성할 때 **엔터티 도출 -> 엔터티 배치 -> 관계 설정 -> 관계명 기술** 의 흐름으로 작업을 진행한다.

#### 정답: 4


### 12
#### 발생 시점에 따른 엔터티의 분류
1. **기본 엔터티(Key Entity)**
    - 독립적으로 생성되는 엔터티
2. **중심 엔터티(Main Entity)**
    - 기본 엔터티와 행위 엔터티의 중간에 존재하는 엔터티
3. **행위 엔터티(Activity Entity, 사건 엔터티)**
    - 2개 이상의 부모 엔터티로부터 발생
    - 비즈니스 프로세스를 실행하면서 생성되는 엔터티
    - 지속적으로 정보가 추가되고 변경되어 데이터양이 가장 많다.

관계 엔터티라는 것은 과연 뭘까... 찾아봐도 딱히 나오는게 없는걸 보면 그냥 이상한 거 집어넣은 것 같다.

#### 정답: 1


### 13
#### 엔터티 명명 규칙
1. 현업업무에서 사용하는 용어
2. 약어 **지양**
3. 단수 명사
4. 유일성 보장
5. 명확성 - 엔터티 생성 의미대로 이름 부여

#### 정답: 1


### 15
#### 속성
- 엔터티가 가지는 최소 의미 단위, 인스턴스의 구성 요소
- 영어로만 공부했어서 헷갈리는데 Attribute이다.
- 엔터티에 대한 자세하고 구체적인 정보를 나타낸다.
- 하나의 엔터티는 두 개 이상의 속성을 갖는다.
- 하나의 인스턴스에서 각각의 속성은 하나의 속성값만 가져야 한다.
- 속성도 집합이다.

#### 엔터티, 인스턴스, 속성, 속성값의 관계
- 한 개의 엔터티는 두 개 이상의 인스턴스 집합이어야 한다.
- 한 개의 엔터티는 두 개 이상의 속성을 갖는다.
- 한 개의 속성은 한 개의 속성값을 갖는다.

#### 정답: 3


### 16
#### 정규화
1. **1차 정규화**
    - 도메인이 원자값
    - 속성의 원자성 확보
    - 다중값 속성을 분리
2. **2차 정규화**
    - 부분 함수 종속성 제거
    - 일부 기본키에만 종속된 속성을 분리
    - 기본키가 하나의 칼럼일 경우에는 생략
    - 부분 함수 종속인 경우
      ![alt text](image.png)
3. **3차 정규화**
    - 이행 함수 종속성 제거
    - 서로 종속 관계가 있는 일반 속성을 분리
    - 이행 함수 종속인 경우
      ![alt text](image-1.png)
4. **BCNF 정규화**
    - 후보키가 기본키 속성 중 일부에 함수 종속적일 경우 다수의 주식별자를 분리
    - 결정자 중 기본키가 아닌 것 제거 였나
    - 전에 전공 수업에서 배운 적이 있으니 찾아보자
5. **4차 정규화**
    - 다치 종속 분리
6. **5차 정규화**
    - 조인 종속 분리

먼저 문제의 DB는 모든 속성이 원자성을 띄므로 1차 정규형은 만족한다. 그러나 현재 주문상품 엔터티의 주문상품명은 주문상품 코드에만 종속적이다. 기본키가 주문번호와 주문상품코드 둘인데 둘 모두에 종속적이지 않으므로 이는 부분 함수 종속적, 즉 2차 정규화가 필요하고 2차 정규화를 진행한 것이다.

근데 나 이 문제 이해를 못하고 변경 전, 변경 후를 보지 못해서 이게 그냥 정규화가 안 되어 있는 것인 줄 알았어... 그렇게 생각하면 앞으로 새롭게 해야할 정규화는 3차 정규화긴 하네...

#### 정답: 2


### 20
아니 이걸 왜 틀린거야 빡대가리야 연관관계 항상 존재하는 관계고 의존관계는 일시적으로 존재하는 관계라는 것을 누가 몰라.

연관관계는 소스코드에서 멤버변수로 선언하여 사용하게 하고 의존관계는 오퍼레이션에서 파라미터 등으로 이용할 수 있도록 되어 있다.

#### 정답: 4


### 21
보기에 나와있는 것 위주로 알아보자.

#### 데이터 모델링의 관계에 대한 설명
1. 관게는 존재적 관계와 행위에 의한 관계로 나누어볼 수 있다.
    - 존재적 관계: 엔터티 간의 상태
    - 행위적 관계: 엔터티 간에 발생하는 행위
2. 관계의 표기법은 관계명, 관계차수, 선택성(선택사양)의 3가지 개념으로 표현한다.

#### 정답: 2


### 24
#### 두 개의 엔터티 사이에서 관계를 도출할 때 확인할 사항
1. 두 개의 엔터티 사이에 관심 있는 연관규칙이 존재하는가?
2. 두 개의 엔터티 사이에 정보의 조합이 발생되는가?
3. 업무기술서, 장표에 관계연결을 가능하게 하는 **동사(Verb)**가 있는가?
4. 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?

#### 정답: 3


### 27
#### 식별자의 분류
**대표성 여부에 따른 분류**
1. **주식별자**
    - 대표성을 만족하는 식별자
2. **보조 식별자**
    - 유일성과 최소성만 만족하는 식별자
    - 참조 관계 연결에 사용할 수 없다.

**생성 여부에 따른 분류**
1. **내부 식별자**
    - 자연스럽게 존재하는 식별자 (=본질식별자)
2. **외부 식별자**
    - 다른 엔터티와의 관계를 통해 생성되는 식별자

**속성 수에 따른 분류**
1. **단일 식별자**
    - 하나의 속성
2. **복합 식별자**
    - 여러 속성

**대체 여부에 따른 분류**
1. **본질 식별자**
    - 대체될 수 없는 식별자
2. **인조 식별자**
    - 인위적으로 만들어지는 대체 가능한 식별자
    - 후보 식별자 중 주식별자로 선정할 것이 없거나 주식별자가 너무 많은 칼럼으로 구성되어 있을 때 사용

일단 여기서 사원 엔터티의 특성에 해당하는 것은 아마 사원의 식별자인 사번의 특성에 대해서 물어보는 것 같다. 현재 사번은 사원 엔터티를 대표하므로 주식별자라고 할 수 있으며 사번 하나의 속성이 식별자로 사용되고 있으므로 단일 식별자이다. 또한 사번은 자연스럽게 존재하는 식별자이기 때문에 내부 식별자이다. 그리고 사번은 인위적으로 만들어지는 인조식별자가 아니다.

#### 정답: 4


### 30
#### 식별자에 따른 관계의 분류
1. **식별 관계**
    - 부모 엔터티의 식별자를 자식 엔터티에서 주식별자로 사용
        - 약한 엔터티: 부모 엔터티에 종속되어 존재
    - 강한 연결 관계 표현
    - 실선 표현
    - 반드시 부모 엔터티에 종속
    - 자식 주식별자 구성에 부모 주식별자 포함 필요
    - 상속받은 주식별자 속성을 타 엔터티에 이전 필요
2. **비식별 관계**
    - 부모 엔터티의 식별자를 자식 엔터티에서 일반 컬럼으로 참조 사용
    - 약한 종속 관계
    - 점선 표현
    - 자식 주식별자 구성을 독립적으로 구성
    - 자식 주식별자 구성에 부모 주식별자 부분 필요
    - 상속받은 주식별자 속성을 타 엔터티에 차단하는 것이 필요
    - 부모 쪽의 관계 참여가 선택관계

#### 데이터 모델링에서 비식별자 관계로 연결하는 경우
1. 엔터티와 엔터티가 1:M 관계의 부모와 자식관계에서 데이터가 부모 없이 자식쪽 엔터티의 인스턴스가 먼저 생성될 수 있을 경우 비식별자 관계로 연결해야 한다.
2. 부모 엔터티의 인스턴스가 자식 엔터티의 인스턴스보다 먼저 소멸하는 경우 비식별자 관게로 연결해야 한다.
3. 자식 엔터티의 식별자가 부모 엔터티의 주식별자를 상속받아 생성하는 것보다 별도의 주식별자를 생성하는 것이 더 유리하다고 판단되는 경우 비식별자 관계로 연결해야 한다.
    - 당연한 밀이지 비식별자 관계 자체가 자식 엔터티가 별도의 주식별자를 독립적으로 구성하는 것이니까

SQL문의 조인 관계를 최소화 하는 경우 식별자 관계로 연결해야 한다. 왜지? 일단 그렇다고 한다.

#### 정답: 3


### 31
전체적인 풀이는 27번의 풀이를 보면 된다. 다시 풀었을 때 맞았다.

#### 정답: 3


## 1과목 2장 데이터 모델과 SQL
### 34
현재 ab는 당연히 자기 자신인 ab를 결정하고 추가로 cde도 결정하므로 후보 키가 될 수 있다.

d는 ab를 결정하고 ab는 cde를 결정하므로 d는 모든 속성을 결정할 수 있다. 즉 후보 키가 될 수 있다.

e->b 이므로 ae->ab이다. 또한 ab->cde 이므로 ae는 모든 속성을 결정할 수 있으며 후보 키가 될 수 있다.

이렇게 차근차근 생각해보니까 또 쉽네. 다음에 똑같이 나오면 풀 수 있을 것 같다.

#### 정답: 3


### 38
현재 모델 테이블에는 유형기능분류코드가 엄청나게 반복되고 있다. **칼럼에 의한 반복적인 속성값을 갖는 형태는 속성의 원자성을 위배한 1차 정규화의 대상**이 된다. 이와 같은 반복적인 속성 나열 형태에서는 각 속성에 대해 'or' 연산자로 연결된 조건들이 사용되는데, 이때 어느 하나의 속성이라도 인덱스가 정의되지 않으면 'or'로 연결된 모든 조건절들이 인덱스를 사용하지 않고 한 번의 전체 데이터 스캔으로 처리되게 되어 성능 저하가 나타날 수 있다. 또한 모든 반복 속성에 인덱스를 생성하면 검색 속도는 좋아지겠지만 반대로 너무 많은 인덱스 때문에 입력, 수정, 삭제의 성능이 저하되므로, 1차 정규화로 자연스럽게 문제가 해결될 수 있도록 해야 한다.

무슨 말인지 알겠다. 우선 칼럼에 의한 반복적인 속성값을 갖는 형태도 속성의 원자성을 위배한 1차 정규화의 대상이라는 것을 알아둬야겠다.

#### 정답: 4


### 39
이건 진짜 어떻게 푸는거지 왜 7개인거지

우선 제 1차 정규화를 통해서 학생 테이블이 학생이랑 LAB실 이용신청 테이블 2개로 나눠지는 건 ok. LAB실 이용 신청 테이블도 지금 보니까 교수도 너무 반복되니까 나눠야겠다. 그러면 학생, LAB실이용신청, 교수 이렇게 3개. 그리고 학과명은 학과번호에 의해 결정될 수 있는데 학과번호는 식별자가 아니니까 얘도 따로 빼자. 그러면 학생 학과, LAB실 이용신청, 교수 이렇게 4개. 학생 테이블은 이정도로 정리하면 될 것 같다.

이번에는 도서대출 테이블. 도서 테이블은 우선 대출도서번호랑 대출도서명이 서로 종속적이므로 빼놔야하니까 대출, 대출도서 로 2개. 답지에 따르면 여기에 추가로 일반 도서 테이블이랑 대출도서 테이블을 나눠서 3개로 나누라고 했는데... 아직은 잘 모르겠다...

#### 정답: 3


### 41
#### 정규화
- **논리** 데이터 모델 상세화 과정의 대표적인 활동
- 논리 데이터 모델의 일관성을 확보하고 중복을 제거하여 속성들이 가장 적절한 엔터티에 배치되도록 한다.
    - 보다 더 신뢰성 있는 데이터구조

개념 데이터 모델이 아니라 논리 데이터 모델이다!!!! 당연한거지!!!

#### 정답: 1


### 46
NULL에 대한건 특별히 배운 적이 없는데 생각보다 잘 맞았네 문제가 나오면...

#### NULL의 특성
- NULL은 아직 정의되지 않은 값으로 0 또는 공백과 다르다.
    - 0은 숫자, 공백은 하나의 문자
- 테이블을 생성할 때 NOT NULL 또는 PRIMARY KEY로 정의되지 않은 모든 데이터 유형은 NULL 값을 포함할 수 있다.
- NULL 값을 포함하는 연산의 경우 결괏값도 NULL 값이다.
    - 모르는 데이터에 숫자를 더하거나 빼도 결과는 마찬가지로 모르는 데이터인 것과 동일
- 결괏값을 NULL이 아닌 다른 값을 얻고자 할 때 NVL/ISNULL 함수를 사용한다.
    - NULL 값의 대상이 숫자 유형 데이터인 경우 주로 0으로, 문자 유형 데이터인 경우는 공백보다는 'x' 같이 해당 시스템에서 의미 없는 문자로 바꾸는 경우가 많다.

#### 정답: 3


### 47
정규화를 수행하면 일반적으로 검색 작업의 성능이 저하된다고 한다.

근데 그게 중요한게 아니라 왜 이게 제2정규화를 수행한 것이지? 왜 제3정규화가 아닌거야? 아 진짜 도저히 모르겠네... 일단 넘어가자

#### 정답: 2


### 48
뭔가 이거는 가장 적절하지 않은 걸 고르라고 한 것 같은데.... 왜냐하면 나머지도 다 맞는 것 같고 오히려 답지에서는 A와 B가 하나의 트랜잭션으로 묶여 처리가 되어야 하므로 커밋은 A와 B를 모두 수행한 다음에 해주어야 한다고 하고... 이것도 나중에 찾아봐야겠다 뭔지...

#### 정답: 2


### 49
일단 전체적인건 46번 풀이를 보면 되고 추가적으로 정리할 것!

#### NULL의 특징
1. NULL 값과 어떤 숫자를 비교한 결과는 항상 **unknown**이다.
2. `NULL = NULL` 연산의 결과는 **FALSE** 또는 **unknown**이다.
3. 집계 함수를 계산할 때 NULL 값은 0으로 처리되는 것이 아닌 계산에서 제외된다.

#### 정답: 1

<br>

## 2과목 1장 SQL 기본
- 은근 많이 맞았다... 물론 헷갈리는 거 투성이었지만...

### 9
헷갈렸던 건 두번째 SQL문이었다. 근데 GPT한테 물어본거랑 답지랑 다르네. 그래서 직접 실행도 해봤더니 답지가 맞는 것 같다

WHERE문을 만족하는 행만 생각했을 때 COL2에서는 NULL 값만 나온다. 이걸 제외하고 생각했을 때 만약 SUM(COL2)가 0을 반환하면 20이 답이고 NULL을 반환하면 NULL이 답인데 아무래도 후자인 것 같다. SUM(COL3)은 20이므로 SUM(COL2)+SUM(COL3) = NULL+20으로 NULL이 최종 답이 되게 된다.

SUM은 일반적으로 NULL을 제외하고 계산을 하지만 계산할 값이 NULL밖에 없을 때는 NULL을 반환한다고 생각하면 될 것 같다. 또한 컬럼과 컬럼사이의 연산은 하나라도 NULL이 들어있을 경우 0으로 생각하는게 아니라 그냥 NULL이라는 것을 기억하자.

#### 정답: 3


### 11
우선 적절한거 고르랬는데 아니란 거 골랐고... 그래도 모르는게 많았다.

1. 서비스 번호는 현재 데이터 타입이 VARCHAR2(10)이다. 또한 ㉠은 서비스 번호가 1인 레코드를 선택한다. 서비스 번호 칼럼의 모든 레코드가 '001'과 같은 숫자 형식으로 입력되어 있어야 오류가 발생하지 않는다.
2. 오라클에서 빈 문자열은 NULL로 입력된다.
3. 오라클에서 빈 문자열은 NULL이므로 IS NULL 조건으로 조회해야 한다.
4. SQL Server에서 빈 문자열은 빈 문자열로 입력되기 때문에 빈 문자열을 찾으려면 IS NULL이 아닌 ='' 조건을 조회해야 한다.

#### 정답: 4


### 13
뭔지는 잘 모르겠지만 1, 2, 3은 가입이 2014년 12월 01일 00시에 발생했고 서비스 종료일시가 2015년 01월 01일 00시 00분 00초와 2015년 01월 31일 23시 59분 59초 사이에 만료되는 데이터를 찾는 조건인ㅔ에 반해 4는 가입 조건은 동일하지만 서비스 종료일시가 2015년 01월 01일 00시 00분 00초에 종료되는 SQL을 찾는 조건이다.

1, 2는 잘 알겠고 3이랑 4가 무슨 차이인지 헷갈렸는데 지금 보니까 3은 SVC_END_DATE를 'YYYYMM'의 형태를 가진 char로 변환한다. 일자는 그냥 없어지기 '201501', 즉 2015년 1월인 애들은 다 해당한다는 말이다. 반면 4는 '201501'을 날짜로 바꿨을 때 나오는 값이 SVC_END_DATE인 애들을 찾는 것이며 일자가 주어지지 않았으므로 TO_DATE('201501', 'YYYYMM')은 자동적으로 해당 연월의 첫번째 날이 반환된다. 즉 2015년 01월 01일 00시 00분 00초를 의미하고 SVC_END_DATE가 정확히 이 값을 가지는 SQL을 찾는 조건이므로 다르다.

**TO_DATE에서 일 정보가 생략되었다면 자동으로 첫 번째 날을 반환한다**는 것을 기억해둬야겠다.

#### 정답: 4


### 15
이건 어떻게 맞춘거지.

우선 **LENGTH는 문자열의 길이를 나타내는 함수**이다. C1은 현재 'A(줄바꿈)A'와 'B(줄바꿈)B(줄바꿈)B'이므로 LENGTH(C1)은 3, 5이다. 또한 **REPLACE는 문자열을 치환하는 함수**로 REPLACE(C1, CHR(10))은 줄바꿈을 C1의 줄바꿈을 제거한다는 것으로 AA, BBB이다. 따라서 LENGTH(REPLACE(C1, CHR(10)))은 2, 3이 된다. 우리가 최종적으로 구하고 싶은 것은 LENGTH(C1) - LENGTH(REPLACE(C1, CHR(10))) + 1 이며 이는 각각 3-2+1 = 2, 5-3+1 = 3이다. 따라서 SUM(CC)는 5

**문자열의 길이를 계산할 때는 줄바꿈까지 계산한다**는 것을 기억하자.

#### 정답: 3


### 16
얘는 맞았고 별표도 안 쳤는데 뒤에서 비슷한 문제를 틀렸기 때문에 한 번 정리하고 넘어가야겠다.

오라클에서 날짜의 연산은 숫자의 연산과 같다. 특정 날짜에 1을 더하면 하루를 더한 결과와 같으므로 1/24/60은 1분을 의미한다. 지금 보니까 하루를 24로 나누면 1시간, 1시간을 60으로 나누면 1분이기 때문에 1분을 의미하는 것 같다. 따라서 1/24/(60/10)은 10분을 의미한다. 1시간을 6으로 나눈다는 뜻. 따라서 2023년 1월 10일 10시에 10분을 더한 2023.01.10 10:10:00가 답이다.

#### 정답: 3


### 17
#### 조건문 함수
1. **CASE WHEN 조건절1 THEN 출력값1 ... ELSE 기본값 END**
    - ELSE 생략 시 NULL이 출력된다.
    - **CASE WHEN NULL THEN 출력값 ELSE 기본값**은 조건이 없으므로 모든 행에서 기본값이 출력된다.
2. **DECODE(칼럼, 기준값1, 출력값1, ..., 기본값)**
    - Oracle 함수
    - 기준값 n이면 출력값 n 출력
    - 지금 보니까 기준값-출력값 쌍으로 존재하는 것 같고 기준값에 맞지 않는다면 기본값으로 출력되는 것 같다.

문제에서는 현재 LOC의 값이 'NEW YORK'일 경우 'EAST'를 출력하고 그 외의 경우에는 'ETC'를 출력하도록 되어있다. 이를 AREA라는 이름으로 출력하도록 한다. 따라서 이와 일치하는 결과를 내놓는 것은 2번이다.

4번의 경우 DECODE(LOC, 'NEW YORK', 'EAST', 'ETC')라고 되어야 맞는 답이다.

#### 정답: 2


### 18
#### NULL 관련 함수
1. **NVL(칼럼, 값)**
    - 칼럼의 NULL을 값으로 변환하여 출력
2. **NVL2(칼럼, 값, 값)**
    - 칼럼의 값을 NULL이면 앞의 값으로, 아니면 뒤의 값으로 변환하여 출력
3. **NULLIF(값, 값)**
    - 앞의 값과 뒤의 값이 같으면 NULL 다르면 앞의 값으로 출력
    - 이건 특정 컬럼의 값을 이용해서 하는게 아니라 그냥 표현식 두 개에서 도출되는 값들을 비교할 때 사용하는 듯
4. **COALESCE(값, 값, ...)**
    - 값들 중 처음으로 나오는 NULL이 아닌 값을 출력
5. **ISNULL(칼럼, 값)**
    - NULL이면 값으로 변환하고 아니면 원래 값 출력
    - SQL server에서 제공하며 NVL과 동일한 의미를 가지고 있는 것 같다.

1번은 해당 포지션이면 1, 아니면 NULL을 값으로 보내며 만약 NULL인 값에 대해서는 0으로 변환하는 과정을 거친다. 2번의 경우 1번과 동일하게 해당 포지션이면 1, 아니면 NULL을 값으로 보내며 NULL인 값에 대해서는 0으로 변환하는 과정을 거친다. 3번의 경우도 동일하다. 반면에 4번은 해당 포지션이 아니어도 1을 반환하며 NULL 값이 반환되는 것이 없으므로 0으로 변환되는 것도 없을 것이며 따라서 결과도 다를 것이다.

#### 정답: 4


### 20
이건 18번에서 다 정리했으므로 넘어가도 될 것 같다. 다시 풀었을 때도 맞았다.

#### 정답: 1


### 21
이걸 별표 친 이유는 1, 3이 대체 무슨 의미인지 궁금해서 그런거였는데 그거에 대해서는 안 나오고 4번이 왜 결과가 다른지만 설명해주네... 일단 4번이 결과가 다른 이뉴는 DEPT를 역순 정렬하기 때문에 다른 것이다. 그러면 대체 1, 3은 무슨 의미인 것인가.

아 1, 3은 1번째 열, 3번째 열을 의미하는 것이다. 그니까 각각 DNAME이랑 DEPTNO를 의미하는 것이지. 내가 예상했던 것과 동일하다.

참고로 DESC나 ASC는 바로 앞에 쓴 컬럼에만 적용되는 것이다. 즉 ORDER BY DNAME, LOC, 3 DESC에서 DESC는 3(DEPTNO)에만 적용되는거지. 그래서 DEPT DESC, LOC, 3 DESC가 다른 결과가 나올 수밖에 없는 것이다.

#### 정답: 4


### 24
#### 단일행 문자형 함수의 종류 (잘 모르는 것만)
1. **CONCAT(문자열1, 문자열2)**
    - 문자열1과 문자열2를 연결
    - Oracle, MySQL에서 유효한 함수
    - 합성 연산자 '||'나 '+'와 동일하다.
2. **SUBSTR/SUBSTRING(문자열, m[, n])**
    - 문자열 중 m 위치에서 n개의 문자 길이에 해당하는 문자를 반환한다.
    - n이 생략될 경우 마지막 문자까지이다.
3. **LTRIM(문자열 [, 지정문자])**
    - 문자열의 왼쪽부터 확인해서 지정 문자가 나타나면 해당 문자를 제거한다.
    - SQL Server에서는 지정문자를 지정할 수 없고 공백만 제거할 수 없다.
    - RTRIM과 TRIM은 각각 문자열의 오른쪽, 문자열의 양쪽에서 제거한다.

문제에서 SUBSTR('Gangneung Wonju', 8, 4)는 문자열의 8번째부터 4만큼의 길이에 해당하는 문자열을 반환하는 것이므로 'ng W'가 반환되어야 한다.

#### 정답: 4


### 27
정말 중요한 점!! **GROUP BY 절은 NULL 데이터도 집계에 포함**하므로 COLB 칼럼의 값에 NULL이 있는 행도 출력된다.

이걸 알고 다시 풀어봤더니 맞았다. 나머지는 다 제대로 알고 있는 것 같다. 그래도 나머지 몇몇을 정리해보자면...

MIN, MAX 함수는 NULL이 아닌 행 중 최소, 최댓값을 구하는 것이다.

그 외에는 더 정리할 것이 없는 것 같다.

#### 정답: 1


### 28
뒷 부분의 ORDER BY 부분을 몰랐기 때문에 틀렸다.

CASE문에 의해서 ID가 999인 경우 0으로 치환되고 그 외에는 원래 ID값으로 생각한다. 따라서 999를 0으로 생각하면 오름차순으로 정렬할 경우 앞에 나오므로 999, 100 순서로 정렬되어야 한다.

#### 정답: 2


### 30
애는 앞에서 해서 그런지 다시 풀었을 때 맞았다.

#### 정답: 3


### 31
이것도 다시 풀어서 맞았다.

1번은 'A'가 출력되는 것 같고 (처음으로 NULL이 아닌 값 출력) 3번이랑 4번은 제대로 써진 건지도 모르겠다. 분명 NVL(칼럼, 값) 형태로 사용이 되어야 하는데 그런 것 같지도 않고... 모르겠다.

#### 정답: 2


### 33
여러 테이블로부터 원하는 데이터를 조회하기 위해서는 전체 테이블 개수에서 최소 N-1개 만큼의 JOIN 조건이 필요하다.

이것도 조금 헷갈려서 별표였는데 생각해보니 당연한거네.

#### 정답: 3


### 35
이것은 헷갈렸던 문항만 정리해보자.

#### JOIN에 대한 설명
1. DBMS 옵티마이저는 FROM 절에 나열된 테이블이 아무리 많아도 항상 **2개의 테이블씩 짝을 지어** JOIN을 수행한다.
2. 대부분 NON EQUI JOIN을 수행할 수 있지만, 때로는 설계상의 이유로 수행이 불가능한 경우도 있다.
3. EQUI JOIN은 '=' 연산자에 의해서만 수행되며, 그 이외의 비교 연산자를 사용하는 경우에는 모두 NON EQUI JOIN이다.

#### 정답: 4


### 38
아 이런 문제는... 너무 복잡하다...

1번은 X.컨텐츠ID=B.컨텐츠ID가 존재하지 않아 단 하나의 컨텐츠라도 비선호로 등록한 고객에 대해서는 모든 컨텐츠가 추천에서 배제된다. 2번은 LEFT OUTER JOIN을 하고 D.컨텐츠ID IS NOT NULL 조건이 있어야 한다.

아... 그냥 모르겠다... 일단 넘어가자...

#### 정답: 4


### 39
특정 생산라인번호에서 생산되는 제품의 제품명을 알기 위해서는 제품과 생산제품만 INNER JOIN을 하고 WHERE문을 통해서 특정 생산라인번호를 걸러내면 된다.

제품과 생산라인 엔터티에는 생산제품과 대응되지 않는 레코드가 있을 수도 있다.

마땅한 JOIN 조건이 없을 경우에는 카르테시안 곱이 발생한다.

#### 정답: 2


### 42
#### NATURAL JOIN
- 같은 이름을 가진 칼럼 전체에 대한 등가 조인
- USING 조건절이나 ON 조건절 사용 불가
- 같은 데이터 유형 칼럼만 조인 가능
- 앨리어스나 테이블명 사용 불가

#### INNER JOIN
- 행에 동일한 값이 있는 칼럼 조인
- JOIN의 디폴트 옵션
- USING 조건절이나 ON 조건절 필수
    - **USING 조건절**
        - 같은 이름을 가진 칼럼 중 등가 조인 대상 칼럼 선택
        - **조건절에 앨리어스나 테이블명 불가**
        - SQL Server에서는 지원하지 않는다.
    - **ON 조건절**
        - 다른 이름을 가진 칼럼 간 조인 가능
        - 앨리어스나 테이블명 필수
- CROSS JOIN이나 OUTER JOIN과 동시 사용 불가
- 두 테이블에 동일 이름 칼럼이 있을 경우 SELECT 절에 앨리어스 필수

다 두 개씩 비슷한 구문이어서 뭔가 에러가 발생하는 것을 찾으라는게 아닐까 했는데 그게 맞았다.

USING 조건절을 이용한 EQUI JOIN에서도 NATURAL JOIN과 마찬가지로 **JOIN 칼럼에 대해서는 ALIAS나 테이블 이름과 같은 접두사를 붙일 수 없다**.

따라서 다음과 같이 바껴야 한다.

SELECT T.REGION_NAME, T.TEAM_NAME, STADIUM_ID, S.STADIUM_NAME
FROM TEAM T INNER JOIN STADIUM S
USING STADIU_ID;

#### 정답: 1


### 44
아... 만약 WHERE절에 A.고객번호 IN (11000, 12000) 조건이 있었다면 2번이 정답이었지만 이게 ON절에 들어가 있고 LEFT OUTER JOIN이기 때문에 모든 고객에 대해서 출력을 하되 데이터는 11000과 12000에 대해서만 한정된 것이다. 따라서 13000, 14000, 15000, 16000 고객 번호는 그냥 다 NULL로 치환한다.

#### 정답: 1


### 45
하... 이것도 진짜 모르겠다. 그냥 (다)도 FULL OUTER JOIN과 동일한 결과를 반환한다네요...

그런 것 같긴 하다. 일단 A.ID랑 B.ID랑 같은거 찾고 A에만 있는거 찾고 B에만 있는거 찾고 이거 다 UNION ALL 하는거니까... FULL OUTER JOIN이랑 동일하겠네.

아 몰라...

#### 정답: 4


### 46
이건 그냥 문제 잘못 읽어서 실수했다. LEFT, FULL, RIGHT 순서인데 LEFT, RIGHT, FULL 순서인 줄 알았다.

#### 정답: 1


### 49
오라클은 OUTER JOIN 구문을 (+) 기호를 사용하여 처리할 수도 있다. 이를 ANSI 문장으로 변경하기 위해서는 INNER쪽 테이블의 조건절을 ON절에 함께 위치시켜야 정상적인 OUTER JOIN을 수행할 수 있다.

현재 INNER쪽 테이블(게시글)의 조건으로 B.삭제여부 = 'N'이 있으므로 이를 ON절에 함께 위치시켜야 한다. 그러므로 1번

#### 정답: 1


## 2과목 2장 SQL 활용
- 자 여기서부터는... 그냥 거의 다 모르고 헷갈리고 틀린거라고 생각하면 된다. 시험 전날인데 이게 맞나?

### 51
#### 서브쿼리
- 하나의 SQL문 안의 SQL문

#### 동작 방식에 따른 서브쿼리 분류
1. **비연관 서브쿼리**
    - 메인쿼리 칼럼을 가지고 있지 않는 서브쿼리
    - 메인쿼리에 값을 제공하기 위한 목적으로 주로 사용한다.
2. **연관 서브쿼리**
    - 메인쿼리의 결과를 조건이 맞는지 확인하기 위한 목적으로 주로 사용한다.

#### 반환 데이터 형태에 따른 분류
1. **단일 행 서브쿼리**
    - 실행 결과가 1건 이하인 서브쿼리
    - 단일 행 비교 연산자와 함께 사용한다.
2. **다중 행 서브쿼리**
    - 실행 결과가 여러 건인 서브쿼리
    - 다중 행 비교 연산자와 함께 사용한다.
        - IN, ANY, ALL, EXISTS(항상 연관 서브쿼리로 사용)
3. **다중 칼럼 서브쿼리**
    - 실행 결과로 여러 칼럼을 반환
    - 주로 메인쿼리의 조건과 비교하기 위해 사용한다.
    - 비교하고자 하는 칼럼의 개수와 위치가 동일해야 한다.

#### 정답: 2


### 52
계속 나를 괴롭혔던 GROUPING SETS, ROLLUP, CUBE...

#### 그룹함수
- 합계 계산 함수
- NULL을 빼고 집계한다.
- 결과값이 없는 행은 출력하지 않는다.
1. **ROLLUP**
    - GROUP BY로 묶인 칼럼의 소계 계산
    - 계층 구조로 GROUP BY의 칼럼 순서가 바뀌면 결과 값이 바뀐다.
    - GPT한테 물어봤는데 여기서 설명하기는 조금 어려울 것 같고 이해는 했다 무슨 말인지.
2. **CUBE**
    - 조합 가능한 모든 값에 대해 다차원 집계
3. **GROUPING SETS**
    - 특정 항목에 대한 소계 계산
    - GROUP BY의 칼럼 순서와 무관하게 개별적으로 처리한다.
    - 사용자가 명시적으로 집계의 조합을 지정한다.

|표현식|출력값|
|----|----|
|GROUP BY ROLLUP(E1, E2)|E1과 E2별 소계 / E1별 소계 / 총합계|
|GROUP BY CUBE(E1, E2)|E1과 E2별 소계 / E1별 소계 / E2별 소계 / 총합계|
|GROUP BY GROUPING SETS (E1, E2)|E1별 소계 / E2별 소계|

우선 1번에서는 COL1 별 합계 값과 전체 합계 값을 구하는 SQL이다. ROLLUP과 CUBE는 인자가 1개만 있을 경우에는 동일하게 인자1별 소계와 총합계를 구하는 식이다. 따라서 3번 4번은 동일하게 COL1별 소계, 총합계를 출력한다. 반면 2번의 경우 GROUPING SETS를 사용하고 있으며 이는 인자에 써진 애들의 소계만 구하게 된다. 따라서 COL1별 소계만 출력하기 때문에 다르다.

#### 정답: 2


### 54
헷갈리는 것만 정리하자.

1. UNION 연산자를 사용한 SQL은 각각의 집합에 GROUP BY 절을 사용할 수 있다.
2. 집합 연산자를 사용한 SQL의 ORDER BY 절은 최종 결과를 정렬하며 가장 마지막 줄에 한 번만 사용할 수 있다.

#### 정답: 4


### 56
이건 내가 헷갈린 것이다. UNION ALL이 수행되면서 중복된 행도 전부 출력을 했지만 UNION이 수행되면서 원래 COL1에 있던 중복된 행도 다 사라졌다. 그래서 1번 같은 결과가 나오는 것이다.

만약 UNION ALL과 UNION의 순서를 바꾸어 진행했다면 2번 같은 결과가 나온다.

#### 정답: 1


### 57
ROLLUP(grade, job)은 grade와 job별 소계, grade별 소계 뿐만 아니라 총 합계도 계산되기 때문에 결과가 다르다. 3번과 4번의 경우 전체 총합계가 나오지만 이를 grade 별로 나누었기 때문에 grade별 전체 총합계가 나와서 원하는 결과와 동일한 결과를 얻을 수 있다.

그 외 자세한 설명은 앞에서 다 했다.

#### 정답:2


### 58
그냥 윈도우 함수를 여기서 다 정리해보자.

#### 윈도우 함수
**순위 함수**
1. **RANK**
    - 중복 순위 포함
2. **DENSE_RANK**
    - 중복 순위 무시 (중간 순위를 비우지 않는다.)
3. **ROW_NUMBER**
    - 단순히 행 번호 표시
    - 값에 무관하게 고유한 순위 부여

**일반 집계 함수**
- SUM, MAX, MIN, AVG, COUNT

**행 순서 함수**
1. **FIRST_VALUE, LAST_VALUE**
    - 첫 값, 끝 값
2. **LAG, LEAD**
    - 이전 행, 이후 행 (Oracle)
    - LEAD(E, A)는 E에서 A번째 행의 값을 호출하는 형태로도 쓰이며 A의 기본값은 1이다.

**비율 관련 함수**
1. **PERCENT_RANK()**
    - 백분율 순서
2. **CUME_DIST()**
    - 현재 행 이하 값을 포함한 누적 백분율
3. **NTILE(A)**
    - 전체 데이터 A등분
4. **RATIO_TO_REPORT**
    - 총합계에 대한 값의 백분율

하... 아직도 정확히는 모르겠는데 4번의 경우는 부서급여합의 결과가 다른 보기와 다르게 집계되기 때문에 결괏값이 다르게 출력된다고 한다. 지금 보니까 뭔가 ORDER BY 사원번호가 있어서 그런 것 같기도 하고? 아 몰라 나오면 틀릴까...

#### 정답: 4


### 59
우선 시스템적으로 회원기본정보와 회원상세정보가 1:1 양쪽 필수 관계임을 보장한다는 것을 기억해야 한다.

1. 1:1 양쪽 필수 관계이므로 회원기본정보 EXCEPT 회원상세정보의 결과는 공집합이다.
2. 1:1 양쪽 필수 관계이므로 회원 기본정보 UNION ALL 회원상세정보의 건수는 회원기본정보의 2배가 된다.
4. 1:1 양쪽 필수 관계이므로 회원기본정보 INTERSECT 회원 상세정보와 회원기본정보 UNION 회원상세정보는 동일한 결과이다.

#### 정답: 3


### 60
#### 계층형 질의
- 계층형 데이터를 조회하기 위해 사용
- Oracle에서 지원

**계층형 데이터**
- 엔터티를 순환관계 데이터 모델로 설계할 때 발생

**CONNECT BY**
- 트리 형태의 구조로 쿼리 수행
- 루트 노드부터 하위 노드의 쿼리를 실행
- **START WITH**: 시작 조건 지정
- **CONNECT BY PRIOR**: 조인 조건 지정
    - **LEVEL**: 검색 항목의 깊이로 최상위 계층의 레벨은 **1** (0이 아니다!!!)
    - **CONNECT_BY_ROOT**: 최상위 계층 값 표시
    - **CONNECT_BY_ISLEAF**: 최하위 계층 값 표시
    - **SYS_CONNECT_BY_PATH**: 계층 구조의 전개 경로 표시

여기다가 추가로 **ORDER SIBLINGS BY**는 좀 헷갈리긴 하지만 해당 컬럼을 기준으로 정렬하라는 것 같기도 하다.

이 지식을 갖고 다시 풀어보면 어느정도 풀리는 것 같기도 하고 아닌 것 같기도 하고.

#### 정답: 2


### 61
오라클 계층형 질의에서 루트 노드의 LEVEL 값은 1이다.

#### 정답: 4


### 62
CONNECT BY 절에 작성된 조건절은 WHERE 절에 작성된 조건절과 다르다. START WITH 절에서 필터링된 시작 데이터는 결과 목록에 무조건 포함이 되며, 이후 CONNECT BY 절에 의해 필터링 된다.

따라서매니저 사원 번호가 NULL인 데이터는 입사일자에 관계없이 무조건 첫번째 데이터로 들어가며 그 이후에 들어가는 데이터는 입사일자가 2013년 이어야한다.

#### 정답: 1


### 63
전부 다 적어보자 그냥

#### 계층형 질의문에 대한 설명
1. SQL Server에서의 계층형 질의문은 CTE(Common Table Expression)를 재귀 호출함으로써 계층 구조를 전개한다.
2. SQL Server에서의 계층형 질의문은 앵커 멤버를 실행하여 기본 결과 집합을 만들고 이후 재귀 멤버를 지속적으로 실행한다.
3. 오라클의 계층형 질의문에서 WHERE 절은 모든 전개를 진행한 이후 필터 조건으로서 조건을 만족하는 데이터만을 추출하는 데 활용된다.
4. 오라클 계층형 질의문에서 PRIOR 키워드는 CONNECT BY 뿐만 아니라 SELECT, WHERE 절에서도 사용할 수 있다.

#### 정답: 4


### 64
우선 부서코드 120의 LVL이 1이므로 이것이 루트 노드라는 것을 알 수 있다. 또한 부서코드 100도 출력이 되고 있으므로 120을 시작으로 상위의 전체 노드(역방향 전개)와 하위의 전체 노드(순방향 전개)를 검색하여 매출액을 출력하는 SQL이다.

그리고 대충 봤을 때 제대로 120을 루트노드로 시작하겠다고 의미를 하는건 1번밖에 없는 것 같은데 1번이 맞긴 하다. 4번도 120을 루트노드로 시작하긴 하는데 역방향 전개를 하여 최상위를 찍고 다시 순방향 전개를 하므로 원하는 결과가 나오지는 않는다.

#### 정답: 1


### 68
이것도 전부 다 적어보자.

#### 서브쿼리에 대한 설명
1. 서브쿼리는 단일 행(Single Row) 또는 복수 행(Multi Row) 비교 연산자와 함께 사용할 수 있다.
2. 서브쿼리는 SELECT 절, FROM 절, HAVING 절, ORDER BY 절 등에서 사용이 가능하다.
3. 서브쿼리의 결과가 복수행 결과를 반환하는 경우에는 IN, ALL, ANY 등의 복수 행 비교 연산자와 사용하여야 한다.
    - '=', '<=', '>=' 등의 연산자는 복수 행 비교 연산자가 아니다.
4. 연관 서브쿼리는 서브쿼리가 메인쿼리 칼럼을 포함하고 있는 형태의 서브쿼리이다.
5. 다중 칼럼 서브쿼리는 서브쿼리의 결과로 여러 개의 칼럼이 반환되어 메인 쿼리의 조건과 비교되는데, SQL Server에서는 현재 지원하지 않는 기능이다.

#### 정답: 2


### 69
중요한 점! RATIO_TO_REPORT는 **파티션 내의 주어진 칼럼 값의 합계에 대한 행별 백문율을 소수점으로 구하는 함수**이다.

나는 VAL2를 보고 NTILE을 써야할 것 같아서 4번을 골랐는데 RATIO_TO_REPORT도 적절한 선택이다. 왜냐하면 지금 보니까 공교롭게도 파티션 내의 합계가 둘 다 100이네;

#### 정답: 4


### 71
GROUP BY나 집계 함수를 사용하지 않고 HAVING 절을 사용하였다고 해서 오류가 발생하지는 않는단다.

나머지는... 그냥 생각하기 싫다...

#### 정답: 3


### 72
이것도 그냥 다 써보자.

#### 서브쿼리에 대한 설명
1. 다중 행 서브쿼리의 비교 연산자는 단일 행 서브쿼리의 비교연산자로 사용될 수 있다.
2. 비연관 서브쿼리가 주로 메인쿼리에 값을 제공하기 위한 목적으로 사용된다.
3. 메인쿼리의 결과가 서브쿼리로 제공될 수도 있고, 서브쿼리의 결과가 메인 쿼리로 제공될 수도 있으므로 실행 순서는 상황에 따라서 달라진다.

#### 정답: 2


### 73
SELECT 절에 사용된 서브쿼리는 단일행 연관 서브쿼리, FROM 절에 사용된 서브쿼리는 Inline View 또는 Dynamic View이며, WHERE 절에 사용된 서브쿼리는 다중행 연관 서브쿼리이다.

특히 SELECT 절에 사용된 서브쿼리는 스칼라 서브쿼리라고 한다. 또한 FROM절에 사용하는 뷰는 인라인 뷰라고 한다.

이미 FROM절에 인라인 뷰로 사원 테이블의 입사년도 조건을 명시하였으므로 WHERE절의 EXISTS 조건은 부서와 사원 테이블 간의 조인 조건에 의해 결과에 어떠한 영향도 미치지 못하므로 삭제되어도 무방하다.

#### 정답: 3


### 74
음 이건 진짜 하기 싫다 우선 넘어가야지

#### 정답: 2


### 75
#### 뷰
- 가상의 테이블
- FROM절에 사용하는 뷰는 인라인 뷰(Inline View)라고 한다.

**장점**
- 독립성: 테이블 구조 변경이 **자동 반영**된다.
- 편리성: 쿼리를 단순하게 작성할 수 있다.
- 보안성: 뷰를 생성할 때 칼럼을 제외할 수 있다.

실제 데이터를 저장하고 있는 뷰를 생성하는 기능을 지원하는 DBMS도 있다고 한다.

#### 정답: 2


### 77
#### 윈도우 함수 문법
- **PARTITION BY**: 그룹핑 기준
- **ORDER BY**: 순위 지정 기준
- **윈도잉절**: 함수의 대상이 되는 행 범위 지정
    - **BETWEEN A AND B**: 구간 지정
        - **N PRECEDING, N FOLLOWING**: N번째 앞 행, N번째 뒤 행
        - **UNBOUNDED PRECEDING, UNBOUNDED FOLLOWING**: 첫 행, 끝 행
        - **CURRENT ROW**: 현재 행
    - **ROWS, RANGE**: 행 지정, 값의 범위 지정

COL2 구문은 부서ID별로 첫 행(UNBOUNDED PRECEDING)부터 현재 행(CURRENT ROW)까지의 범위에서 SUM값을 구한다. 근데 현재 행이 어딘데? 아 앞에서 COL1에서 WHERE절과 함께 걸러낸 순간을 의미하나 그런 것 같다. 그래서 2500 7500 7500이 나오는거여.

#### 정답: 2


### 78
아 이것도 보기 싫다... 근데 뭐가 뭔지는 은근 알 것 같기도 하고...

#### 정답: 2


### 79
지금 보면 사용된 연산자가 단일행 비교 연산자이다. 따라서 1개 이하의 결과를 반환해야하는데 지금 보면 2개 이상의 행이 리턴되고 있다. 따라서 '단일 행 하위 질의에 2개 이상의 행이 리턴되었습니다.' 라는 오류가 발생하게 된다.

#### 정답: 1


### 80
얘는 이제 잘 알아서 다시 풀었을 때 맞음

#### 정답: 1


### 81
가능한 모든 조합을 반환하고 있으므로 2번

1번의 경우 쥰내 거대하고 쓸데없는 테이블을 만들어낸다.

#### 정답: 2


### 82
JOB과 DEPTNO의 평균을 구하고 전체 평균을 계산해야하므로 (JOB, DEPNO)가 인자로 하나만 들어간 2번이 정답이다.

#### 정답: 2


### 84
윈도우 함수는 결과에 대한 함수처리이기 때문에 결과 건수는 줄지 않는다.

#### 정답: 3


### 88
GROUP BY 절의 집합을 원본으로 하는 데이터를 WINDOW FUNCTION과 함께 사용한다면 오류가 발생하지 않는다.

#### 정답: 3


### 91
REVOKE문을 사용하여 권한을 취소하면 권한을 취소당한 사용자가 WITH GRANT OPTION을 통해서 다른 사용자에게 허가했던 권한들도 모두 연쇄적으로 취소된다. 굳이 CASCADE가 명시적으로 작성되어 있지 않아도 그런가보다.

#### 정답: 3


### 94
얘는 소릭히 왜 틀렸는지 모르겠다. 그냥 1번이 정답이라고 할래.

#### 정답: 1


### 95
얘는 다시 풀어서 잘 맞았다.

#### 정답: 2


### 97
얘는 LAG가 뭔지 헷갈려서 별표를 친 건데 이젠 LAG도 뭔지 알고 맞았으니까 됐다.

#### 정답: 3


